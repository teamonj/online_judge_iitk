-- phpMyAdmin SQL Dump
-- version 4.1.12
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Jul 18, 2014 at 03:55 PM
-- Server version: 5.5.36
-- PHP Version: 5.4.27

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- Database: `online judge`
--

-- --------------------------------------------------------

--
-- Table structure for table `contests`
--

CREATE TABLE IF NOT EXISTS `contests` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `contest_id` text NOT NULL,
  `contest_name` text NOT NULL,
  `contest_type` text NOT NULL,
  `start_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `end_time` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `contest_desc` text NOT NULL,
  `contests_admins` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=10 ;

--
-- Dumping data for table `contests`
--

INSERT INTO `contests` (`id`, `contest_id`, `contest_name`, `contest_type`, `start_time`, `end_time`, `contest_desc`, `contests_admins`) VALUES
(1, 'MAYLUNCH14', 'May Lunchtime', 'ICPC', '2014-05-18 15:30:00', '2014-05-18 18:30:00', 'May Lunchtime is for Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.', 'Triveni Mahatha'),
(2, 'MAYCOOK14', 'May Cook Off', 'ICPC', '2014-05-18 03:30:00', '2014-05-18 15:30:00', 'May Cook Off is for Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.', 'Proneet Verma'),
(3, 'MAYLONG14', 'May Long Challenge', 'ICPC', '2014-05-03 09:30:00', '2014-05-13 09:30:00', 'May Long Challenge is for Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.', 'Abhilash Kumar'),
(9, 'COOK47', 'June Cook Off', 'short', '2014-06-22 16:00:00', '2014-06-23 06:30:00', 'june cook off', 'triveni');

-- --------------------------------------------------------

--
-- Table structure for table `files_submitted`
--

CREATE TABLE IF NOT EXISTS `files_submitted` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(40) NOT NULL,
  `prob_id` varchar(80) NOT NULL,
  `lang` varchar(20) NOT NULL,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `status` int(11) NOT NULL,
  `runtime` float NOT NULL,
  `memory` float NOT NULL,
  `contestid` varchar(80) NOT NULL,
  `points` double NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=322 ;

--
-- Dumping data for table `files_submitted`
--

INSERT INTO `files_submitted` (`id`, `username`, `prob_id`, `lang`, `time`, `status`, `runtime`, `memory`, `contestid`, `points`) VALUES
(171, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(172, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(173, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(174, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(175, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(176, 'sid', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MayLT', 0),
(177, 'triveni', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MAYLONG14', 0),
(178, 'triveni', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MAYLONG14', 0),
(179, 'triveni', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MAYLONG14', 0),
(180, 'triveni', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MAYLONG14', 0),
(181, 'triveni', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'MAYLONG14', 0),
(182, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(183, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(184, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(185, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(186, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(187, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(188, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(189, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(190, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(191, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(192, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(193, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(194, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(195, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(196, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(197, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(198, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(199, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(200, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(201, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(202, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(203, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(204, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(205, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(206, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(207, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(208, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(209, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(210, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(211, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(212, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(213, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(214, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(215, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(216, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'practice', 0),
(217, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(218, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(219, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(220, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(221, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(222, '', 'sum', 'c', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(223, '', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(224, '', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(225, '', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(226, 'fugli', 'sum', 'cpp', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(227, 'fugli', 'sum', 'cpp', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(228, 'fugli', 'sum', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(229, 'fugli', 'sum', 'cpp', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(230, 'fugli', 'sum', 'cpp', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(231, 'fugli', 'sum', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(232, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(233, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(234, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(235, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(236, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(237, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(238, 'aadilh', 'COMPNPARSE', 'c', '0000-00-00 00:00:00', 1110, -1, -1, 'MAYLONG14', 0),
(239, 'aadilh', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(240, 'aadilh', 'sum', 'c', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(241, 'aadilh', 'sum', 'c', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(242, 'aadilh', 'sum', 'cpp', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(243, 'aadilh', 'sum', 'cpp', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(244, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(245, 'triveni', 'sumid', 'c', '0000-00-00 00:00:00', 120, -1, -1, 'practice', 0),
(246, 'triveni', 'sumid', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(247, 'triveni', 'sumid', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(248, 'triveni', 'sumid', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(249, 'triveni', 'sum', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(250, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(251, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(252, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 114, -1, -1, 'practice', 0),
(253, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 113, -1, -1, 'practice', 0),
(254, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(255, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(256, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(257, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(258, 'triveni', '11', 'cpp', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(259, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 112, -1, -1, 'practice', 0),
(260, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(261, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(262, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(263, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(264, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(265, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(266, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(267, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(268, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(269, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(270, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(271, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(272, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(273, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(274, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(275, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(276, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(277, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(278, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(279, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(280, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(281, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(282, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(283, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(284, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(285, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(286, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(287, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(288, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(289, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(290, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(291, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(292, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(293, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(294, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(295, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(296, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(297, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(298, 'aadilh', 'COMPNPARSE541', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'MAYLONG14', 0),
(299, 'aadilh', 'COMPNPARSE541', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'MAYLONG14', 0),
(300, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(301, 'triveni', 'sum', 'c', '0000-00-00 00:00:00', 111, -1, -1, 'practice', 0),
(302, 'triveni', 'sum', 'c', '2014-06-23 10:28:50', 111, -1, -1, 'practice', 0),
(303, 'triveni', 'sum', 'c', '2014-06-23 10:29:35', 111, -1, -1, 'practice', 0),
(304, 'triveni', 'sum', 'c', '2014-06-23 10:30:13', 1110, -1, -1, 'practice', 0),
(305, 'triveni', 'sum', 'c', '2014-06-23 10:30:58', 1110, -1, -1, 'practice', 0),
(306, 'triveni', 'sum', 'c', '2014-06-23 10:32:29', 1110, -1, -1, 'practice', 0),
(307, 'triveni', 'sum', 'c', '2014-06-23 10:34:36', 1110, -1, -1, 'practice', 0),
(308, 'triveni', 'sum', 'c', '2014-06-23 10:39:07', 1110, -1, -1, 'practice', 0),
(309, 'triveni', 'sum', 'c', '2014-06-23 10:45:09', 1110, -1, -1, 'practice', 0),
(310, 'triveni', 'sum', 'c', '2014-06-23 10:54:42', 111, -1, -1, 'practice', 0),
(311, 'triveni', 'sum', 'c', '2014-06-23 10:56:21', 1110, -1, -1, 'practice', 0),
(312, 'triveni', 'sum', 'c', '2014-06-23 11:01:44', 114, -1, -1, 'practice', 0),
(313, 'triveni', 'sum', 'c', '2014-06-23 11:02:51', 114, -1, -1, 'practice', 0),
(314, 'triveni', 'sum', 'c', '2014-06-23 11:03:47', 111, -1, -1, 'practice', 0),
(315, 'triveni', 'sum', 'c', '2014-06-23 11:20:09', 111, -1, -1, 'practice', 0),
(316, 'triveni', 'sum', 'c', '2014-06-23 11:20:49', 114, -1, -1, 'practice', 0),
(317, 'triveni', 'COMPNPARSE541', 'c', '2014-06-27 19:11:30', 1110, -1, -1, 'MAYLONG14', 0),
(318, 'triveni', 'sum', 'c', '2014-07-01 09:41:58', 113, -1, -1, 'practice', 0),
(319, 'triveni', 'sum', 'c', '2014-07-01 09:51:52', 120, -1, -1, 'practice', 0),
(320, 'triveni', 'sum', 'c', '2014-07-01 09:53:00', 114, -1, -1, 'practice', 0),
(321, 'triveni', 'sum', 'c', '2014-07-01 09:53:45', 114, -1, -1, 'practice', 0);

-- --------------------------------------------------------

--
-- Table structure for table `leader`
--

CREATE TABLE IF NOT EXISTS `leader` (
  `usrnm` text NOT NULL,
  `score` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `leader`
--

INSERT INTO `leader` (`usrnm`, `score`) VALUES
('usr1', 0),
('usr1', 0),
('usr3', 234),
('usr3', 789),
('usr4', 546),
('usr5', 465),
('usr6', 123),
('erw', 444),
('udr', 789),
('tyu', 777),
('wqe', 456),
('etqr', 574);

-- --------------------------------------------------------

--
-- Table structure for table `problems`
--

CREATE TABLE IF NOT EXISTS `problems` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `problem_id` text NOT NULL,
  `problem_name` text NOT NULL,
  `contest_id` text NOT NULL,
  `contest_name` text NOT NULL,
  `problem_statement` text NOT NULL,
  `short_desc` text NOT NULL,
  `input_desc` text NOT NULL,
  `output_desc` text NOT NULL,
  `constraints` text NOT NULL,
  `sample_input` text NOT NULL,
  `sample_output` text NOT NULL,
  `total_submissions` int(11) NOT NULL,
  `accepted_submissions` int(11) NOT NULL,
  `num_input_file` int(11) NOT NULL,
  `time_limit` int(11) NOT NULL,
  `mem_limit` int(11) NOT NULL,
  `difficulty` int(11) NOT NULL,
  `points` int(11) NOT NULL DEFAULT '10',
  `author` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=89 ;

--
-- Dumping data for table `problems`
--

INSERT INTO `problems` (`id`, `problem_id`, `problem_name`, `contest_id`, `contest_name`, `problem_statement`, `short_desc`, `input_desc`, `output_desc`, `constraints`, `sample_input`, `sample_output`, `total_submissions`, `accepted_submissions`, `num_input_file`, `time_limit`, `mem_limit`, `difficulty`, `points`, `author`) VALUES
(2, 'UPNDOWN', 'Ups and Downs', 'MAYLONG14', 'May Long Challenge', 'You will be given a zero-indexed array A. You need to rearrange its elements in such a way that the following conditions are satisfied:\nA[i] < A[i+1] if i is even.\nA[i] > A[i+1] if i is odd.\nIn other words the following inequality should hold: A[0] > A[1] < A[2] > A[3] < A[4], and so on. Operations > and < should alter.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'The first line contains a single integer T denoting the number of test cases. The first line of each test case contains an integer N, that is the size of the array A. The second line of each test case contains the elements of array A', 'For each test case, output a single line containing N space separated integers, which are the elements of A arranged in the required order. If there are more than one valid arrangements, you can output any of them.', '1 <= N <= 100000\nSum of N in one test file <= 600000\n1 <= A[i] <= 10^9', '2\r\n2\r\n3 2\r\n3\r\n10 5 2', '2 3\r\n2 10 5\r\n', 157, 112, 0, 2, 5, 2, 10, 'Triveni Mahatha'),
(3, 'BTHETREE', 'Build The Tree', 'MAYLONG14', 'May Long Challenge', 'Given a rooted tree with N nodes. Nodes of the tree are numbered from 1 to N. Node 1 is the root. You need to add M nodes to it in the given order. All the nodes have values. Cost for adding a node A with value va to another node B with value vb is va*vb. There is an additional cost of y (so total cost of va*vb+y) if B has atleast x child nodes. After node A has been added to another node B it becomes a child of B.\r\nAfter adding a node A to the tree, nodes next in list can be added to A also. You need to calculate the total minimal cost to add all M nodes in given order.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'The first line of input contains N. The second line of input contains N integers representing the values of nodes in order from node 1 to node N. N-1 lines follow, each line defines an edge. Each line has 2 integers, which says that those 2 nodes are connected.\r\nNext line of input contains an integer Q, denoting the number of queries you need to answer. Each query consists of 2 lines. The first line of each query has 3 integers, M x y. The second line of each query has M integers representing the values of the nodes to be added in order.\r\nNote that in each query, M nodes are added to the initial tree, and hence changes made in previous query should not be considered in later queries', 'For each query, output a single line containing the minimal total cost to add all the nodes in given order.', '1 <= N <= 100000\n1 <= x <= 1000\n1 <= y <= 1000\n1 <= Q <= 100\n1 <= M <= 100\n1 <= Values of all nodes in input <= 1000', '3\r\n2 2 3\r\n1 2\r\n2 3\r\n2\r\n2 2 10\r\n10 10\r\n3 2 10\r\n1 2 2', '40\r\n6', 68, 33, 0, 5, 5, 3, 10, 'Triveni Mahatha'),
(35, 'COMPNPARSE541', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(36, 'COMPNPARSE542', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 10, 6, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(37, 'COMPNPARSE543', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(38, 'COMPNPARSE544', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(39, 'COMPNPARSE545', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(40, 'COMPNPARSE546', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 2107, 632, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(41, 'COMPNPARSE547', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(42, 'COMPNPARSE548', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(43, 'COMPNPARSE549', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(44, 'COMPNPARSE5410', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(45, 'COMPNPARSE5411', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(46, 'COMPNPARSE5412', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(47, 'COMPNPARSE5413', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(48, 'COMPNPARSE5414', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(49, 'COMPNPARSE5415', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(50, 'COMPNPARSE5416', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(51, 'COMPNPARSE5417', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(52, 'COMPNPARSE5418', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(53, 'COMPNPARSE5419', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(54, 'COMPNPARSE5420', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 2, 10, 'Triveni Mahatha'),
(55, 'COMPNPARSE5421', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(56, 'COMPNPARSE5422', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(57, 'COMPNPARSE5423', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(58, 'COMPNPARSE5424', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(59, 'COMPNPARSE5425', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(60, 'COMPNPARSE5426', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(61, 'COMPNPARSE5427', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(62, 'COMPNPARSE5428', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha');
INSERT INTO `problems` (`id`, `problem_id`, `problem_name`, `contest_id`, `contest_name`, `problem_statement`, `short_desc`, `input_desc`, `output_desc`, `constraints`, `sample_input`, `sample_output`, `total_submissions`, `accepted_submissions`, `num_input_file`, `time_limit`, `mem_limit`, `difficulty`, `points`, `author`) VALUES
(63, 'COMPNPARSE5429', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(64, 'COMPNPARSE5430', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 3, 10, 'Triveni Mahatha'),
(65, 'COMPNPARSE5451', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(66, 'COMPNPARSE5452', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(67, 'COMPNPARSE5453', 'Compilers and Parsers', 'MAYLONG14', 'May Long Challenge', 'Lira is now very keen on compiler development. :) She knows that one of the most important components of a compiler, is its parser. A parser is, in simple terms, a software component that processes text, and checks it''s semantic correctness, or, if you prefer, if the text is properly built. As an example, in declaring and initializing an integer, in C/C++, you can''t do something like: int = x ;4 as the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be: int x = 4; Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Given some expressions which represent some instructions to be analyzed by Lira''s compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there''s no such a prefix.', 'Input will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.', 'For each expression you should output the length of the longest prefix that is valid or 0 if there''s no such a prefix.', '1 <= T <= 500\n1 <= The length of a single expression <= 106\nThe total size all the input expressions is no more than 5*106', '3', '4', 107, 63, 0, 3, 5, 1, 10, 'Triveni Mahatha'),
(75, 'GERALD06', 'Chef and Strange Graph', 'practice', 'Practice', '&lt;p&gt;Chef has a connected undirected graph &lt;strong&gt;G&lt;/strong&gt; without multiedges and self-loops. A graph is called connected if there exists a path between any two vertices of the graph. This graph, &lt;strong&gt;G&lt;/strong&gt; has an awesome property: it contains at least one vertex with degree at least 4. &lt;br /&gt; One day Chef was playing with his graph. He constructed a graph &lt;strong&gt;L(G)&lt;/strong&gt; based on the graph &lt;strong&gt;G&lt;/strong&gt;.&lt;br /&gt; The vertices of graph &lt;strong&gt;L(G)&lt;/strong&gt; are the edges of graph &lt;strong&gt;G&lt;/strong&gt;. Two vertices in the graph &lt;strong&gt;L(G)&lt;/strong&gt; are connected with an undirected edge if and only if the&lt;br /&gt; corresponding edges in graph &lt;strong&gt;G&lt;/strong&gt; share a common vertex.&lt;/p&gt;\n&lt;p&gt;Today Chef has lost his favorite graph &lt;strong&gt;G&lt;/strong&gt;. But he has the graph &lt;strong&gt;L(G)&lt;/strong&gt;. Please help Chef, restore the graph &lt;strong&gt;G&lt;/strong&gt; from the graph &lt;strong&gt;L(G)&lt;/strong&gt;.&lt;/p&gt;', 'Chef has a connected undirected graph G without multiedges and self-loops. A graph is called connected if there exists a path between any two vertices of the graph5', 'The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case contains two integers N and M - the number of vertices in L(G) and the number of edges in it. The next M lines\ncontain description of the edges. Each line contains two integers Ai, Bi - indices of vertices, connecting by the current edge. Consider L(G)\nvertices are numbered from 1 to N.', 'For each test case in the first line output an integer K - the number of vertices in the graph G. The next N lines should contain the description of the edges of the graph G (the i-th edge of G should correspond to the i-th vertex of L(G)).\nYou should number vertices in graph G from 1 to K. If there are multiple answers you can print any of them. Also you can insert whitespaces in your output if you want.', '\n    1 &lt;= T, N, M &lt;= 5000;\n    1 &lt;= Ai, Bi &lt;= N;\n    Given graph L(G) is connected and doesn&#039;t contain multiedges and self-loops.\n    It&#039;s guaranteed that sum of all M values for all test cases doesn&#039;t exceed 5000.\n    It&#039;s guaranteed that for each test the answer exists.', '2\n4 6\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n5 8\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n1 5\n2 5', '5\n2 1\n1 3\n1 4\n1 5\n5\n1 2\n1 3\n1 4\n1 5\n2 3', 0, 0, 1, 2, 2, 2, 10, 'triveni'),
(82, 'sum', 'Sum the Numbers', 'practice', 'Practice', '<p>Sum the two numbers given as <span style="text-decoration: underline;"><strong>input</strong></span>.</p>', 'Sum the numbers', 'First line will contain an integer T, denoting the number of test cases. T lines follow:\nEach line contains two numbers a and b.', 'Output should contain T lines, each line having one integer, the sum of two values.', '1<T<1001<a,b<10^18', '2\n5 3\n10 15', '8\n25', 0, 0, 2, 2, 512, 1, 10, 'triveni'),
(83, 'sumid', 'Sum', 'practice', 'Practice', '<p>Sum two numbers</p>', 'bla bla bla', 'apne aap se dekho be sum krna ni aata ??', 'btaya toh sum nikalna hai `', 'no contraints', '2\n2', '5', 0, 0, 1, 1, 1, 3, 10, 'triveni'),
(87, 'nothng', 'Nothing', 'may cook off', 'Practice', '<p>just print "nothing" on screen and prove that "Nothing is Possible"</p>', 'prove "Nothing is Possible"', 'no input', 'nothing', 'no constraints', '', 'nothing', 0, 0, 0, 1, 1, 1, 10, 'triveni'),
(88, 'n', 'jw', 'june cook off', 'Practice', '<p>kjdkjvc</p>', 'vdskjnc', 'kjvkvj', 'kjvvkjvb', 'jdkvvskjv', 'kjvbkjvb', 'kjbvkjbv', 0, 0, 1, 1, 1, 1, 0, 'triveni');

-- --------------------------------------------------------

--
-- Table structure for table `rankings`
--

CREATE TABLE IF NOT EXISTS `rankings` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` text NOT NULL,
  `contest_id` text NOT NULL,
  `score` int(11) NOT NULL,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=7 ;

--
-- Dumping data for table `rankings`
--

INSERT INTO `rankings` (`id`, `username`, `contest_id`, `score`, `update_time`) VALUES
(5, 'aadilh', 'MAYLONG14', 50, '2014-06-23 10:21:40'),
(6, 'aadilh', 'overall', 50, '2014-06-23 10:21:40');

-- --------------------------------------------------------

--
-- Table structure for table `temp_users`
--

CREATE TABLE IF NOT EXISTS `temp_users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `emailId` varchar(255) NOT NULL,
  `college` varchar(255) NOT NULL,
  `r_key` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

-- --------------------------------------------------------

--
-- Table structure for table `users`
--

CREATE TABLE IF NOT EXISTS `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `emailId` varchar(255) NOT NULL,
  `College` varchar(255) NOT NULL,
  `disabled` tinyint(1) NOT NULL DEFAULT '0',
  `admin` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=13 ;

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`id`, `username`, `password`, `name`, `emailId`, `College`, `disabled`, `admin`) VALUES
(2, 'sidgupta', 'e2fc714c4727ee9395f324cd2e7f331f', 'Siddharth Gupta', 'sidgupta@iitk.ac.in', 'IIT Kanpur', 0, 0),
(3, 'triveni', '6715e65193b1b47b07c047d89fc572e1', 'Triveni Mahatha', 'trivenim@gmail.com', 'IIT Kanpur', 0, 1),
(5, 'hayataadil', '5f4dcc3b5aa765d61d8327deb882cf99', 'Aadil Hayat', 'hayataadil@live.com', 'IIT Kanpur', 0, 0),
(6, 'vidnani', '5f4dcc3b5aa765d61d8327deb882cf99', 'Vijay Idnani', 'idnani@gmail.com', 'IIT Kanpur', 0, 0),
(8, 'aadilh', '5f4dcc3b5aa765d61d8327deb882cf99', 'Aadil Hayat', 'hayataadil@gmail.com', 'IIT Kanpur', 0, 0),
(9, 'vandana', '125a77f1085bf9c374f91aee6912863c', 'Vandana Gautam', 'vandii@iit.ac.in', 'IIT Kanpur', 0, 0),
(10, 'ghost_25', '22d7fe8c185003c98f97e5d6ced420c7', 'sawan', 'ksawan@iitk.ac.in', 'iitk', 0, 0),
(11, 'debusharma', 'f5f71e2fdc8ddc868db76f822116be93', 'Devansh Sharma', 'devanshshrm94@gmail.com', 'IIT Kanpur', 0, 0),
(12, 'fugli', 'd8578edf8458ce06fbc5bb76a58c5ca4', 'fugli', 'kraj280695@gmail.com', 'MIT', 0, 0);

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
